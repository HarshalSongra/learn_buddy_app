<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<h4>What is JVM Architecture:</h4>
<p>JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in a java code. JVM is a part of JRE(Java Runtime Environment).<br /> Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java enabled system without any adjustment. This is all possible because of JVM.<br /> When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM.<br /><br /></p>
<h4>Java Class File:</h4>
<p>A Java class file is a file containing Java bytecode and having .class extension that can be executed by JVM. A Java class file is created by a Java compiler from .java files as a result of successful compilation. As we know that a single Java programming language source file (or we can say .java file) may contain one class or more than one class. So if a .java file has more than one class then each class will compile into a separate class files.<br /><br /></p>
<h4>Java Identifiers:</h4>
<p>In programming languages, identifiers are used for identification purposes. In Java, an identifier can be a class name, method name, variable name, or label. For example :<br /> public class Test<br /> {<br /> public static void main(String[] args)<br /> {<br /> int a = 20;<br /> }<br /> }<br /><br /></p>
<h4>Data types in Java:</h4>
<p>There are majorly two types of languages.<br /> 1. First, one is Statically typed language where each variable and expression type is already known at compile time. Once a variable is declared to be of a certain data type, it cannot hold values of other data types. Example: C, C++, Java.<br /> 2. The other is Dynamically typed languages. These languages can receive different data types over time. Example: Ruby, Python<br /><br /> Java has two categories of data: <br /> Primitive Data Type: such as boolean, char, int, short, byte, long, float, and double<br /> Non-Primitive Data Type or Object Data type: such as String, Array, etc.<br /><br /></p>
<h5>primitive data types:</h5>
<p>1. boolean: boolean data type represents only one bit of information either true or false, but the size of the boolean data type is virtual machine-dependent. Values of type boolean are not converted implicitly or explicitly (with casts) to any other type. But the programmer can easily write conversion code.<br /> 2. byte: The byte data type is an 8-bit signed two&rsquo;s complement integer. The byte data type is useful for saving memory in large arrays.<br /> 3. short: The short data type is a 16-bit signed two&rsquo;s complement integer. Similar to byte, use a short to save memory in large arrays, in situations where the memory savings actually matters.<br /> 4. int: It is a 32-bit signed two&rsquo;s complement integer.<br /> 5. long: The long data type is a 64-bit two&rsquo;s complement integer. <br /> 6. float: The float data type is a single-precision 32-bit IEEE 754 floating-point. Use a float (instead of double) if you need to save memory in large arrays of floating-point numbers.<br /> 7. double: The double data type is a double-precision 64-bit IEEE 754 floating-point. For decimal values, this data type is generally the default choice.<br /> 8. char: The char data type is a single 16-bit Unicode character.<br /><br /></p>
<h5>Non-Primitive Data Type or Reference Data Types:</h5>
<p>String: Strings are defined as an array of characters. The difference between a character array and a string in Java is, the string is designed to hold a sequence of characters in a single variable whereas, a character array is a collection of separate char type entities. Unlike C/C++, Java strings are not terminated with a null character.</p>
<h5>Example:</h5>
<p>// Declare String without using new operator <br /> String s = "HelloWorld"; <br /> // Declare String using new operator <br /> String s1 = new String("HelloWorld"); <br /><br /> Class: A class is a user-defined blueprint or prototype from which objects are created. It represents the set of properties or methods that are common to all objects of one type. In general, class declarations can include these components, in order: <br /> 1. Modifiers: A class can be public or has default access (Refer this for details).<br /> 2. Class name: The name should begin with a initial letter (capitalized by convention).<br /> 3. Superclass(if any): The name of the class&rsquo;s parent (superclass), if any, preceded by the keyword extends. A class can only extend (subclass) one parent.<br /> 4. Interfaces(if any): A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword implements. A class can implement more than one interface.<br /> 5. Body: The class body surrounded by braces, { }.<br /><br /> Object: It is a basic unit of Object-Oriented Programming and represents the real-life entities. A typical Java program creates many objects, which as you know, interact by invoking methods. An object consists of : <br /> 1. State: It is represented by attributes of an object. It also reflects the properties of an object.<br /> 2. Behavior: It is represented by methods of an object. It also reflects the response of an object with other objects.<br /> 3. Identity: It gives a unique name to an object and enables one object to interact with other objects.<br /><br /> Interface: Like a class, an interface can have methods and variables, but the methods declared in an interface are by default abstract (only method signature, nobody).<br /> *Interfaces specify what a class must do and not how. It is the blueprint of the class.<br /> *An Interface is about capabilities like a Player may be an interface and any class implementing Player must be able to (or must implement) move(). So it specifies a set of methods that the class has to implement.<br /> *If a class implements an interface and does not provide method bodies for all functions specified in the interface, then the class must be declared abstract.<br /> *A Java library example is, Comparator Interface. If a class implements this interface, then it can be used to sort a collection.<br /><br /> Array: An array is a group of like-typed variables that are referred to by a common name. Arrays in Java work differently than they do in C/C++. The following are some important points about Java arrays.<br /> *In Java, all arrays are dynamically allocated. (discussed below) <br /> *Since arrays are objects in Java, we can find their length using member length. This is different from C/C++ where we find length using size.<br /> *A Java array variable can also be declared like other variables with [] after the data type.<br /> *The variables in the array are ordered and each has an index beginning from 0.<br /> *Java array can be also be used as a static field, a local variable or a method parameter.<br /> *The size of an array must be specified by an int value and not long or short.<br /> *The direct superclass of an array type is Object. <br /><br /></p>
<h4>Java.io Package in Java:</h4>
<p>This package provides for system input and output through data streams, serialization and the file system. Unless otherwise noted, passing a null argument to a constructor or method in any class or interface in this package will cause a NullPointerException to be thrown.<br /><br /> <strong>There are Some Packages we Use Frequently:</strong><br /> 1. BufferedInputStream.<br /> 2. BufferOutputStream. <br /> 3. BufferdReader.<br /> 4. BufferedWriter.<br /> 5. ByteArrayInputStream.<br /> 6. ByteArrayOutputStream.<br /><br /></p>s
<h4>Variables in Java:</h4>
<p>A variable is a name given to a memory location. It is the basic unit of storage in a program.<br /> *The value stored in a variable can be changed during program execution.<br /> *A variable is only a name given to a memory location, all the operations done on the variable effects that memory location.<br /> *In Java, all the variables must be declared before use.<br /><br /> <strong>1. Local Variables:</strong> A variable defined within a block or method or constructor is called local variable.<br /> These variable are created when the block in entered or the function is called and destroyed after exiting from the block or when the call returns from the function.<br /> The scope of these variables exists only within the block in which the variable is declared. i.e. we can access these variable only within that block.<br /> Initilisation of Local Variable is Mandatory.<br /><br /> <strong>Sample Program 1:</strong><br /> public class StudentDetails<br /> { <br /> public void StudentAge() <br /> { <br /> // local variable age <br /> int age = 0; <br /> age = age + 5; <br /> System.out.println("Student age is : " + age); <br /> } <br /> public static void main(String args[]) <br /> { <br /> StudentDetails obj = new StudentDetails(); <br /> obj.StudentAge(); <br /> } <br /> } <br /><br /> <strong>2. Instance Variables:</strong> Instance variables are non-static variables and are declared in a class outside any method, constructor or block.<br /> As instance variables are declared in a class, these variables are created when an object of the class is created and destroyed when the object is destroyed.<br /> Unlike local variables, we may use access specifiers for instance variables. If we do not specify any access specifier then the default access specifier will be used.<br /> Initilisation of Instance Variable is not Mandatory. Its default value is 0<br /> Instance Variable can be accessed only by creating objects.<br /><br /> <strong>3. Static Variables:</strong> Static variables are also known as Class variables.<br /> These variables are declared similarly as instance variables, the difference is that static variables are declared using the static keyword within a class outside any method constructor or block.<br /> Unlike instance variables, we can only have one copy of a static variable per class irrespective of how many objects we create.<br /> Static variables are created at the start of program execution and destroyed automatically when execution ends.<br /> Initilisation of Static Variable is not Mandatory. Its default value is 0<br /> If we access the static variable like Instance variable (through an object), the compiler will show the warning message and it won&rsquo;t halt the program. The compiler will replace the object name to class name automatically.<br /> If we access the static variable without the class name, Compiler will automatically append the class name.<br /><br /></p>
<h4>Classes and Objects in Java:</h4>
<p>Classes and Objects are basic concepts of Object Oriented Programming which revolve around the real life entities. <br /> <strong>Class:</strong><br /> A class is a user defined blueprint or prototype from which objects are created. It represents the set of properties or methods that are common to all objects of one type. In general, class declarations can include these components, in order:<br /> 1. Modifiers : A class can be public or has default access (Refer this for details).<br /> 2. Class keyword: class keyword is used to create a class.<br /> 3. Class name: The name should begin with a initial letter (capitalized by convention).<br /> 4. Superclass(if any): The name of the class&rsquo;s parent (superclass), if any, preceded by the keyword extends. A class can only extend (subclass) one parent.<br /> 5. Interfaces(if any): A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword implements. A class can implement more than one interface.<br /> 6. Body: The class body surrounded by braces, { }.<br /><br /> <strong>Object:</strong><br /> It is a basic unit of Object Oriented Programming and represents the real life entities. A typical Java program creates many objects, which as you know, interact by invoking methods. An object consists of : <br /> 1. State : It is represented by attributes of an object. It also reflects the properties of an object.<br /> 2. Behavior : It is represented by methods of an object. It also reflects the response of an object with other objects.<br /> 3. Identity : It gives a unique name to an object and enables one object to interact with other objects.<br /><br /> <strong>Inheritance in Java:</strong><br /> Inheritance is an important pillar of OOP(Object Oriented Programming). It is the mechanism in java by which one class is allow to inherit the features(fields and methods) of another class.<br /> <strong>Encapsulation in Java:</strong><br /> Encapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates.Other way to think about encapsulation is, it is a protective shield that prevents the data from being accessed by the code outside this shield.<br /> <strong>Abstraction in Java:</strong><br /> Data Abstraction is the property by virtue of which only the essential details are displayed to the user.The trivial or the non-essentials units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.<br /> <strong>Dynamic Method Dispatch or Runtime Polymorphism in Java:</strong><br /> Method overriding is one of the ways in which Java supports Runtime Polymorphism. Dynamic method dispatch is the mechanism by which a call to an overridden method is resolved at run time, rather than compile time.<br /> <strong>Overloading in Java:</strong><br /> Overloading allows different methods to have the same name, but different signatures where the signature can differ by the number of input parameters or type of input parameters or both. Overloading is related to compile-time (or static) polymorphism.<br /> <strong>Overriding in Java:</strong><br /> In any object-oriented programming language, Overriding is a feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes. When a method in a subclass has the same name, same parameters or signature, and same return type(or sub-type) as a method in its super-class, then the method in the subclass is said to override the method in the super-class.<br /><br /></p>
<h4>Loops in Java:</h4>
<p><strong>While Loop:</strong> A while loop is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition. The while loop can be thought of as a repeating if statement.<br /> Syntax :<br /> while (boolean condition)<br /> {<br /> loop statements...<br /> }<br /><br /> <strong>For loop:</strong>for loop provides a concise way of writing the loop structure. Unlike a while loop, a for statement consumes the initialization, condition and increment/decrement in one line thereby providing a shorter, easy to debug structure of looping.<br /> Syntax<br /> for (initialization condition; testing condition; increment/decrement)<br /> {<br /> statement(s)<br /> }</p>
<p><strong>Do-While Loop:</strong>do while loop is similar to while loop with only difference that it checks for condition after executing the statements, and therefore is an example of Exit Control Loop.<br /> Syntax:<br /> do{<br /> statements..<br /> }while (condition);</p>
<h4>Decision Making in Java (if, if-else, switch, break, continue, jump):</h4>
<p>Decision Making in programming is similar to decision making in real life. In programming also we face some situations where we want a certain block of code to be executed when some condition is fulfilled.<br /> A programming language uses control statements to control the flow of execution of program based on certain conditions. These are used to cause the flow of execution to advance and branch based on changes to the state of a program.<br /><br /> <strong>If Statement:</strong><br /> if statement is the most simple decision making statement. It is used to decide whether a certain statement or block of statements will be executed or not i.e if a certain condition is true then a block of statement is executed otherwise not.<br /> Syntax:<br /> if(condition) <br /> {<br /> // Statements to execute if<br /> // condition is true<br /> }<br /><br /> <strong>If-Else Statement:</strong><br /> The if statement alone tells us that if a condition is true it will execute a block of statements and if the condition is false it won&rsquo;t. But what if we want to do something else if the condition is false. Here comes the else statement. We can use the else statement with if statement to execute a block of code when the condition is false.<br /> Syntax:<br /> if (condition)<br /> {<br /> // Executes this block if<br /> // condition is true<br /> }<br /> else<br /> {<br /> // Executes this block if<br /> // condition is false<br /> }<br /><br /> <strong>Nested-If:</strong><br /> A nested if is an if statement that is the target of another if or else. Nested if statements means an if statement inside an if statement. Yes, java allows us to nest if statements within if statements. i.e, we can place an if statement inside another if statement.<br /> Syntax:<br /> if (condition1) <br /> {<br /> // Executes when condition1 is true<br /> if (condition2) <br /> {<br /> // Executes when condition2 is true<br /> }<br /> }<br /><br /> <strong>Switch Statement in Java:</strong><br /> The switch statement is a multi-way branch statement. It provides an easy way to dispatch execution to different parts of code based on the value of the expression. Basically, the expression can be byte, short, char, and int primitive data types. Beginning with JDK7, it also works with enumerated types ( Enums in java), the String class and Wrapper classes.<br /> Syntax of Switch-case : <br /> switch(expression)<br /> {<br /> case value1 : // Statemens break; // break is optional<br /> case value2 :// Statements break; // break is optional<br /> default : // Statements<br /> }</p>
<h4>Operators in Java:</h4>
<p><strong>Arithmetic Operators:</strong><br /> They are used to perform simple arithmetic operations on primitive data types.<br /> * : Multiplication<br /> / : Division<br /> % : Modulo<br /> + : Addition<br /> &ndash; : Subtraction<br /><br /> <strong>Unary Operators:</strong><br /> Unary operators need only one operand. They are used to increment, decrement or negate a value.<br /> &ndash; :Unary minus, used for negating the values.<br /> + :Unary plus, used for giving positive values. Only used when deliberately converting a negative value to positive.<br /> ++ :Increment operator, used for incrementing the value by 1. There are two varieties of increment operator.<br /> Post-Increment : Value is first used for computing the result and then incremented.<br /> Pre-Increment : Value is incremented first and then result is computed.<br /> &mdash; : Decrement operator, used for decrementing the value by 1. There are two varieties of decrement operator.<br /> Post-decrement : Value is first used for computing the result and then decremented.<br /> Pre-Decrement : Value is decremented first and then result is computed.<br /> ! : Logical not operator, used for inverting a boolean value.<br /><br /> <strong>Assignment Operator:</strong><br /> =&rsquo; Assignment operator is used to assign a value to any variable. It has a right to left associativity, i.e value given on right hand side of operator is assigned to the variable on the left and therefore right hand side value must be declared before using it or should be a constant.<br /><br /> <strong>Relational Operators :</strong><br /> These operators are used to check for relations like equality, greater than, less than. They return boolean result after the comparison and are extensively used in looping statements as well as conditional if else statements.<br /> ==, Equal to : returns true of left hand side is equal to right hand side.<br /> !=, Not Equal to : returns true of left hand side is not equal to right hand side.<br /> &lt; , less than : returns true of left hand side is less than right hand side.<br /> &lt;=, less than or equal to : returns true of left hand side is less than or equal to rig8ht hand side.<br /> &gt;, Greater than : returns true of left hand side is greater than right hand side.<br /> &gt;=, Greater than or equal to: returns true of left hand side is greater than or equal to right hand side.<br /><br /> <strong>Logical Operators :</strong><br /> These operators are used to perform &ldquo;logical AND&rdquo; and &ldquo;logical OR&rdquo; operation, i.e. the function similar to AND gate and OR gate in digital electronics. One thing to keep in mind is the second condition is not evaluated if the first one is false, i.e. it has a short-circuiting effect. Used extensively to test for several conditions for making a decision.<br /> &amp;&amp;, Logical AND : returns true when both conditions are true.<br /> ||, Logical OR : returns true if at least one condition is true.<br /><br /></p>
<h4>Arrays in Java:</h4>
<p>An array is a group of like-typed variables that are referred to by a common name. Arrays in Java work differently than they do in C/C++.<br /> *In Java all arrays are dynamically allocated.<br /> *Since arrays are objects in Java, we can find their length using the object property length. This is different from C/C++ where we find length using sizeof.<br /> *A Java array variable can also be declared like other variables with [] after the data type.<br /> *The variables in the array are ordered and each have an index beginning from 0.<br /> *Java array can be also be used as a static field, a local variable or a method parameter.<br /> *The size of an array must be specified by an int value and not long or short.<br /> *The direct superclass of an array type is Object.<br /> *Every array type implements the interfaces Cloneable and java.io.Serializable.<br /><br /> <strong>One-Dimensional Arrays :</strong><br /> The general form of a one-dimensional array declaration is.<br /> type var-name[];<br /> OR<br /> type[] var-name;<br /> An array declaration has two components: the type and the name. type declares the element type of the array. The element type determines the data type of each element that comprises the array. Like an array of integers, we can also create an array of other primitive data types like char, float, double, etc. or user-defined data types (objects of a class). Thus, the element type for the array determines what type of data the array will hold.<br /><br /> <strong>Multidimensional Arrays:</strong><br /> Multidimensional arrays are arrays of arrays with each element of the array holding the reference of other array. These are also known as Jagged Arrays. A multidimensional array is created by appending one set of square brackets ([]) per dimension<br /> *Example:<br /> int[][] intArray = new int[10][20]; //a 2D array or matrix<br /> int[][][] intArray = new int[10][20][10]; //a 3D array<br /><br /></p>
<h4>String class in Java:</h4>
<p>String is a sequence of characters. In java, objects of String are immutable which means a constant and cannot be changed once created.<br /> Creating a String: <br /> String s = &ldquo;HelloWorld&rdquo;;<br /> String s = new String (&ldquo;HelloWorld&rdquo;);<br /><br /></p>
<h4>Constructors in Java;</h4>
<p>Constructors are used to initialize the object&rsquo;s state. Like methods, a constructor also contains collection of statements(i.e. instructions) that are executed at time of Object creation.<br /> <strong>Need of Constructor:</strong><br /> Think of a Box. If we talk about a box class then it will have some class variables (say length, breadth, and height). But when it comes to creating its object(i.e Box will now exist in computer&rsquo;s memory), then can a box be there with no value defined for its dimensions. The answer is no.<br /> So constructors are used to assign values to the class variables at the time of object creation, either explicitly done by the programmer or by Java itself (default constructor).<br /><br /> <strong>Types of constructor:</strong><br /> <strong>1. No-Argument Constructor:-</strong>No-argument constructor: A constructor that has no parameter is known as default constructor. If we don&rsquo;t define a constructor in a class, then compiler creates default constructor(with no arguments) for the class. And if we write a constructor with arguments or no-arguments then the compiler does not create a default constructor.<br /> <strong>2. Parameterized Constructor:</strong>A constructor that has parameters is known as parameterized constructor. If we want to initialize fields of the class with your own values, then use a parameterized constructor.</p>
<h4>Constructor Overloading in Java:</h4>
<p>In addition to overloading methods, we can also overload constructors in java. Overloaded constructor is called based upon the parameters specified when new is executed.<br /> Sometimes there is a need of initializing an object in different ways. This can be done using constructor overloading. For example, Thread class has 8 types of constructors. If we do not want to specify anything about a thread then we can simply use default constructor of Thread class, however if we need to specify thread name, then we may call the parameterized constructor of Thread class with a String args like this:<br />Thread t= new Thread (" MyThread "); <br /><br /></p>
<h4>Exceptions in Java:</h4>
<p>An exception is an unwanted or unexpected event, which occurs during the execution of a program i.e at run time, that disrupts the normal flow of the program&rsquo;s instructions.<br /> <strong>Error:</strong> An Error indicates serious problem that a reasonable application should not try to catch.<br /> <strong>Exception:</strong>Exception indicates conditions that a reasonable application might try to catch.<br /> <br /><br /><strong>Understanding OutOfMemoryError Exception in Java:</strong><br /> In Java, all objects are stored in the heap. They are allocated using new operator. The OutOfMemoryError Exception in Java looks like this:<br /> Exception in thread "main" java.lang.OutOfMemoryError: Java heap space<br /> OutOfMemoryError usually means that you&rsquo;re doing something wrong, either holding onto objects too long, or trying to process too much data at a time. Sometimes, it indicates a problem that&rsquo;s out of your control, such as a third-party library that caches strings, or an application server that doesn&rsquo;t clean up after deploys. And sometimes, it has nothing to do with objects on the heap.</p>
<h4>Interfaces in Java:</h4>
<p>Like a class, an interface can have methods and variables, but the methods declared in an interface are by default abstract (only method signature, no body). <br /> *Interfaces specify what a class must do and not how. It is the blueprint of the class.<br /> *An Interface is about capabilities like a Player may be an interface and any class implementing Player must be able to (or must implement) move(). So it specifies a set of methods that the class has to implement.<br /> *If a class implements an interface and does not provide method bodies for all functions specified in the interface, then the class must be declared abstract.<br /> *A Java library example is, Comparator Interface. If a class implements this interface, then it can be used to sort a collection.<br /><br /></p>
<h4>Java Interface methods:</h4>
<p>There is a rule that every member of interface is only and only public whether you define or not. So when we define the method of the interface in a class implementing the interface, we have to give it public access as child class can&rsquo;t assign the weaker access to the methods.<br /> As defined, every method present inside interface is always public and abstract whether we are declaring or not. Hence inside interface the following methods declarations are equal.<br /><br /> void methodOne();<br /> public Void methodOne();<br /> abstract Void methodOne();<br /> public abstract Void methodOne();<br /><br /> *public : To make this method available for every implementation class.<br /> *abstract : Implementation class is responsible to provide implementation.<br /><br /></p>
<h4>File Handling in Java:</h4>
<p>The File class is Java&rsquo;s representation of a file or directory path name. Because file and directory names have different formats on different platforms, a simple string is not adequate to name them. The File class contains several methods for working with the path name, deleting and renaming files, creating new directories, listing the contents of a directory, and determining several common attributes of files and directories.<br /> *It is an abstract representation of file and directory pathnames.<br /> *A pathname, whether abstract or in string form can be either absolute or relative. The parent of an abstract pathname may be obtained by invoking the getParent() method of this class.<br /> *First of all, we should create the File class object by passing the filename or directory name to it. A file system may implement restrictions to certain operations on the actual file-system object, such as reading, writing, and executing. These restrictions are collectively known as access permissions.<br /> *Instances of the File class are immutable; that is, once created, the abstract pathname represented by a File object will never change.<br /><br /> <strong>Creating Object of File:</strong> File a = new File("/usr/local/bin/file1");<br /><br /> 1. File(File parent, String child) : Creates a new File instance from a parent abstract pathname and a child pathname string.<br /> 2. File(String pathname) : Creates a new File instance by converting the given pathname string into an abstract pathname.<br /> 3. File(String parent, String child) : Creates a new File instance from a parent pathname string and a child pathname string.<br /> 4. File(URI uri) : Creates a new File instance by converting the given file: URI into an abstract pathname.<br /><br /></p>
<h4>Multithreading in Java:</h4>
<p>Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU. Each part of such program is called a thread. So, threads are light-weight processes within a process.<br /><br /> Threads can be created by using two mechanisms :<br /> 1. Extending the Thread class<br /> 2. Implementing the Runnable Interface<br /> We create a class that extends the java.lang.Thread class. This class overrides the run() method available in the Thread class. A thread begins its life inside run() method. We create an object of our new class and call start() method to start the execution of a thread. Start() invokes the run() method on the Thread object.<br /><br /></p>
</body>
</html>